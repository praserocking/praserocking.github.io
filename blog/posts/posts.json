{
  "posts": [
    {
      "filename": "raspberry-pi-5-home-server.md",
      "title": "From Microservices to Metal: My First Journey into Yocto and k3s Integration",
      "date": "2026-02-04",
      "description": "A senior microservices engineer's first-time journey into custom Linux distribution building, documenting the challenges of integrating k3s into a Yocto-based IVI system - from learning BitBake and cgroups v2 requirements to navigating licensing roadblocks and achieving a working containerized proof of concept.",
      "category": "experience",
      "tags": ["yocto", "k3s", "embedded-linux", "bitbake", "cgroups", "automotive", "first-time", "learning-journey", "containerization", "custom-distro"],
      "excerpt": "A microservices engineer's first dive into Yocto custom Linux distribution building, navigating cgroups v2 requirements, licensing roadblocks, and kernel configuration challenges to successfully integrate k3s into an automotive IVI system.",
      "content": "As a senior engineer who primarily works on distributed microservices which are device facing for the most part of my career, my only experience with operating systems has been as a user, never as a distro builder. When I needed to add k3s (lightweight Kubernetes) to a Yocto-based In-Vehicle Infotainment (IVI) system with ADB support, I quickly realized this would be very different from my usual `apt install` or `yum install` workflow. This was my first rodeo with Yocto-based distro building.\n\nThis is the story of my first venture into custom Linux distribution building - complete with the mistakes, discoveries, and eventual success.\n\n## The Challenge and Learning Yocto\n\nThe task seemed straightforward: integrate k3s into an existing Yocto-based IVI system while maintaining ADB functionality. I chose k3s over full Kubernetes because it's designed for resource-constrained environments - a single binary around 40-60MB with lower resource requirements, simplified deployment, and full Kubernetes API compatibility. In automotive environments where every MB matters, k3s was perfect for bringing cloud-native orchestration to embedded systems.\n\nComing from traditional package management, I had to learn an entirely new approach where everything gets built into the image during distribution creation. My first step was understanding what BitBake actually does - unlike traditional package managers that install pre-compiled binaries, BitBake orchestrates building everything from source. I had to learn BB files (recipes) that define how to fetch, configure, compile, and package software, BBAppend files to modify existing recipes, and how BitBake pulls Git repositories directly during the build process.\n\nThis was a complete paradigm shift. Instead of grabbing a pre-built k3s package, I needed recipes that would fetch the k3s source code, handle Go dependencies, compile for the target architecture, and package everything properly. Fortunately, I discovered ARM Research had already created a meta-k3s layer at https://gitlab.com/arm-research/smarter/meta-k3s with complete k3s recipes and proper Go dependency handling. This seemed like it would save me months of work.\n\n## The cgroups Reality Check\n\nMy first major roadblock came when I learned about cgroups - a Linux kernel feature I'd honestly never paid attention to before. Control Groups are essential for resource management, process isolation, and container orchestration systems like Kubernetes. The problem: k3s requires pure cgroups v2, but my IVI distro was using cgroups v1. Modern k3s versions (especially v1.31+ with containerd 2.0) don't support cgroups v1 or hybrid v1/v2 modes at all - only pure cgroups v2 is supported. This manifested as k3s failing to start properly, container runtime errors, and resource management failures.\n\nI initially thought I could just upgrade the kernel, but learned that cgroups are tied directly to the kernel version - you can't install or upgrade cgroups in userspace. In embedded systems, this is particularly challenging because stability is paramount, kernels are tested and validated for specific hardware, and certification requirements often require specific kernel versions.\n\nRather than attempting a complete kernel upgrade (risky and potentially breaking hardware compatibility), I took a more surgical approach: rebuilding the kernel with modified CONFIG_CGROUP_* options to disable cgroups v1 flags and enable cgroups v2 flags. This gave me cgroups v2 support without the massive risk of upgrading to an entirely different kernel version.\n\n## The Legal Roadblock and PoC Approach\n\nJust when I thought I had the technical challenges figured out, I hit an unexpected wall: legal and licensing complications. I discovered I couldn't use libcgroups in my commercial IVI distro due to licensing restrictions. There was an entire list of components banned from commercial images due to legal complications: systemd, libcgroups, procps, and iptables.\n\nThis created an almost impossible situation. Even with cgroups v2 in the kernel, I couldn't include the userspace tools needed to actually manage those cgroups. Through investigation, I discovered the system had automated checks for specific licensing terms - particularly GNU GPL v2 - based on which certain dependencies were automatically blocked from the build.\n\nRather than getting stuck in legal negotiations, I made a strategic decision: scope this down to a Proof of Concept. I started removing the license checks to allow the required dependencies to be included in the build. This wasn't a production solution, but it was a way to prove technical feasibility, understand other challenges, and get k3s working with all its required dependencies. Sometimes in embedded development, you need to separate the \"can it work technically?\" question from the \"can we ship it commercially?\" question.\n\n## Success and Container Insights\n\nAfter all the challenges - from cgroups compatibility to licensing roadblocks - it finally worked. I successfully got a simple Node.js container running on my custom Yocto-built Linux system with k3s orchestration. This was genuinely euphoric - seeing that container start up and respond properly was validation that all the complex integration work had paid off.\n\nThis success led me to explore deeper into containerization technology. I had conversations with a principal engineer who helped dispel some common misconceptions about containers. There's a perceived notion that containers are heavy on the OS, bumping CPU and memory requirements significantly. This turns out to be largely a myth.\n\nContainers are actually quite elegant in their resource usage: they use the same kernel as the host OS (no extra memory for separate operating systems), cgroups split RAM and CPU allocation defining exactly how much each container can access, system calls are trapped at the kernel level for security, and containers are essentially different user spaces running on the same kernel - not separate heavy operating systems. This architecture provides cloud-native orchestration, solves the \"it works on my machine\" problem, offers resource efficiency much lighter than VMs, and provides proper isolation without hypervisor overhead.\n\n## What I Learned\n\nThis experiment taught me several important lessons. Embedded development is fundamentally different from traditional Linux work - what works on your laptop doesn't automatically work on embedded systems, kernel features that seem optional can be hard requirements, and dependency chains matter where one simple addition can require fundamental system changes.\n\nLicensing can be as limiting as technical constraints in commercial products, with every component needing legal vetting and companies maintaining \"banned lists\" to avoid issues. The ARM Research meta-k3s layer saved me months of work, showing how invaluable open source community contributions are. Sometimes you need to separate learning from shipping - the technical proof of concept was valuable even though it didn't solve commercial challenges.\n\nLooking back, I thoroughly enjoyed this experience. Being part of Amazon's devices organization and Amazon Smart Vehicles gave me the opportunity to try something genuinely challenging and educational. Everyone wants to build a custom operating system at some point - this k3s/Yocto integration was the closest I've gotten to building my own OS and running it on real hardware.\n\nThis project taught me about the depth of Linux internals, container orchestration reality, embedded development constraints, and the Yocto ecosystem. The project proved that containerization and cloud-native technologies can work in automotive and embedded systems. While my PoC approach meant I didn't solve all commercial challenges, the technical learning was invaluable.\n\nFor anyone considering a similar integration: expect multiple roadblocks, embrace the complexity, and remember that sometimes the journey teaches you more than the destination. The embedded world has different constraints than traditional development, but that's what makes it interesting.\n\n---\n\n*This was my first adventure into custom Linux distribution building with k3s integration. The experience definitely sparked interest in more embedded containerization experiments, though I now have much more respect for the complexity involved.*\n"
    },
    {
      "filename": "raspberry-pi-5-home-server.md",
      "title": "Why Raspberry Pi 5 Still Beats Mini PCs for Home Servers",
      "date": "2026-02-01",
      "description": "Real-world comparison of Raspberry Pi 5 vs used mini PCs for home servers, covering power efficiency (5W vs 17-19W idle), cost analysis (₹4k vs ₹10k), and practical experience running Pi-hole, Samba, Transmission, and Plex over one year.",
      "category": "experience",
      "tags": ["pi5", "arm", "debate", "experience", "raspberrypi"],
      "excerpt": "After a year of running Pi-hole, Samba, Transmission, and Plex on my Raspberry Pi 5, I'm convinced it still beats used mini PCs for home servers. Despite my neighbor's argument about raw performance, the Pi 5's 5W idle consumption, ₹6,000 lower upfront cost, and ₹2,000 annual power savings make it the practical choice for most home automation needs.",
      "content": "I've been noticing a lot of advice suggesting the purchase of used mini PCs for home servers, but for my needs, the Raspberry Pi 5 remains the superior option.\n\nThis came up while talking to a neighbour who argued with me on why a used or refurbished mini PC with 4th or 5th gen Intel processor would be absolutely faster than any Pi. This got me thinking about the setup I've been running for about a year now. While he's technically right about raw performance, there's more to the story.\n\nThere's been a growing trend in the home server community recommending used mini PCs as the go-to solution. While these devices certainly have their place, I believe many people are overlooking the continued advantages of the Raspberry Pi 5 for typical home server workloads.\n\n## My Home Server Stack\n\nI utilize my Pi 5 to manage my entire home, running a standard stack that includes:\n\n- **Pi-hole** for blocking ads in the network via DNS Proxy. I use some generic gravity lists I found online and adblock checker says I block 97% of ads at home - every device from smartphones to smart TVs benefits from ad-free browsing.\n- **Samba** for straightforward local file sharing with 500GB storage. I use this to share FLAC songs across devices at home. Simple to set up and works seamlessly with Windows, macOS, and Linux machines.\n- **Transmission** as my async torrent client for torrenting anything. It is absolutely necessary. The web interface makes remote management easy and integrates well with the rest of my media stack.\n- **Plex** for my home streaming needs. I have my own collection of movies which I love to watch and not found anywhere online. I use Direct Play as it is better for syncing subtitles - when transcoding on the fly, subtitles are faster, which shows the Pi is a bit slow there.\n\n## Why Pi 5 is \"Grown Up\" Hardware\n\nThe Pi 5 is very grown up. I have been using Pi from the 3B model and it has been a great improvement. The hardware now feels truly mature compared to previous generations.\n\nI now have an **M.2 SSD** on my Pi 5 which is awesome - no more SD card bottlenecks. The **processor and memory** have also improved so much. With **Gigabit Ethernet** and **PCIe Gen 2 support**, I no longer face the bandwidth bottlenecks that older Pi models had. The Pi 5 even has **CPU fan pins** now, allowing for proper active cooling when needed.\n\nThe expansion possibilities are incredible - there's even an option to have a **40 TOPS NPU** as a Pi HAT, or anything for that matter as a HAT. I have even used a **CAN HAT** at work. This ecosystem is awesome.\n\n## Power Efficiency: The Killer Feature\n\nThe best part? It's incredibly efficient, **idling at 5W and peaking at 25W** - though that peak never happens for my use case. Try beating that with a mini PC **idling at 17-19W and peaking at 65W maybe**? It is a major load.\n\nThis efficiency difference has real-world implications. My UPS can run the Pi for **7-8 hours** without main power, while a mini PC can go for **2-3 hours only**. If you calculate the power consumption, the Pi consumes about **₹2,000 less per year** on the power bill compared to a mini PC.\n\nReliability has also been excellent; with a few management scripts handling automatic service restarts and basic monitoring, I've experienced only about an hour of downtime over the past several months.\n\n## Issues I've Faced\n\nTo be honest, there are a few minor issues. Sometimes the Pi will want to update/upgrade - that's about **5 minutes downtime every 3 to 4 months**. I also have to reset Eth0 sometimes when it configures itself to throttle at 100Mbps while my internet is 300Mbps. So I have a maintenance script to unblock this throttle when I feel it's happening.\n\nAlso, it's ARM meaning many softwares are not built for this architecture. I have to download and build stuff at times, which is problematic. This is one reason why I don't run k8s on this one. Everything is managed on the OS directly, no containers.\n\n## Cost Reality Check\n\nHere's where the economics get interesting. I got my Pi 5 for less than ₹4,000, while used mini PCs with 4th or 5th gen Intel processors are hitting ₹10,000 almost. That's 2.5x the cost upfront, before even considering the ongoing electricity costs.\n\n## When Each Makes Sense\n\nAfter running this setup for a year, here's my honest assessment:\n\n**Choose Pi 5 if you:**\n- Want a simple, silent, and low-power home server\n- Run basic services like Pi-hole, Samba, Plex (Direct Play), and torrenting\n- Value power efficiency and UPS backup time\n- Don't mind occasional ARM compatibility issues\n- Prefer direct OS management over containerization\n- Want to save money both upfront and on electricity bills\n\n**Choose Mini PC if you:**\n- Need heavy transcoding for multiple simultaneous streams\n- Run resource-intensive applications or multiple VMs\n- Require x86-specific software without ARM alternatives\n- Want to run Kubernetes or complex container orchestration\n- Need more than 8GB of RAM\n- Don't mind 2.5x higher upfront costs and ₹2,000 extra annually on power\n\nFor the typical home server stack I've described - Pi-hole, file sharing, torrenting, and media streaming - the Pi 5 is the more practical choice despite its limitations.\n\n## Final Thoughts\n\nMy neighbor was technically right about raw performance, but he missed the bigger picture. The Pi 5 isn't about having the fastest processor or the most RAM. It's about finding the right balance of performance, efficiency, cost, and reliability for typical home server needs.\n\nYes, I have to deal with ARM compatibility issues and occasional network throttling. Yes, updates cause brief downtime every few months. But when I look at my setup running 24/7, consuming just 5W while blocking 97% of ads, sharing my FLAC collection, managing torrents, and streaming my personal movie library - all while costing ₹6,000 less upfront and ₹2,000 less annually - the Pi 5 makes perfect sense.\n\nSometimes the newest trend isn't necessarily the best solution for your specific use case. The Raspberry Pi 5 continues to offer the best balance for most home automation and media server needs.\n"
    }
  ]
}
